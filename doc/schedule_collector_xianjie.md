# SkyEye平台与采集器衔接架构设计

## 一、架构概述

SkyEye监控系统分为两个核心组件：skyii-server(平台端)和skyii-collector(采集器端)。本文从架构师视角设计两者的衔接方案，构建一个完整、高效、可靠的监控数据采集体系。

![架构概览](../doc/images/architecture_overview.png)

## 二、核心通信模型

### 2.1 通信模式

采用**混合通信模式**：

1. **平台→采集器**：主动推送（WebSocket/MQTT）+ 被动拉取（HTTP轮询）
2. **采集器→平台**：HTTP REST API + WebSocket实时反馈

### 2.2 通信协议

| 交互类型 | 协议类型 | 说明 |
|---------|---------|------|
| 任务下发 | HTTP/WebSocket | 支持实时任务推送和定期轮询两种模式 |
| 状态汇报 | HTTP | 心跳包与状态上报 |
| 数据上传 | HTTP | 采集结果批量上传 |
| 指令控制 | WebSocket | 平台向采集器发送实时控制指令 |
| 配置同步 | HTTP | 配置文件/插件更新 |

## 三、任务调度与采集集成架构

### 3.1 数据模型衔接

```
┌─────────────────┐          ┌─────────────────┐          ┌─────────────────┐
│  TaskSchedule   │──────────▶  TaskBatch      │──────────▶  CollectorTask   │
└─────────────────┘  生成     └─────────────────┘  拆分     └─────────────────┘
       │                              │                             │
       │                              │                             │
       ▼                              ▼                             ▼
┌─────────────────┐          ┌─────────────────┐          ┌─────────────────┐
│  Device+Metric  │          │  Collector      │          │  MetricData     │
└─────────────────┘          └─────────────────┘          └─────────────────┘
```

各实体关系：
- TaskSchedule：调度任务定义，包含设备和指标组合
- TaskBatch：单次调度生成的任务批次
- CollectorTask：最小执行单元，由采集器执行
- Device：监控目标设备
- Metric：需要采集的指标
- Collector：采集器实例
- MetricData：采集结果数据

### 3.2 服务组件设计

#### 平台端组件

1. **TaskSchedulerService**
   - 职责：根据调度计划触发任务执行
   - 功能：Cron解析、任务触发、下次执行时间计算

2. **CollectorManagerService** 
   - 职责：管理采集器生命周期和分配
   - 功能：注册、心跳检测、负载均衡、状态监控

3. **TaskBatchService**
   - 职责：生成并管理任务批次
   - 功能：批次创建、采集器分配、任务状态跟踪

4. **TaskDispatcherService**
   - 职责：向采集器分发任务
   - 功能：任务推送、任务队列管理、优先级排序

5. **DataCollectionService**
   - 职责：接收并处理采集结果
   - 功能：数据存储、数据清洗、异常检测

#### 采集器端组件

1. **TaskReceiverModule**
   - 职责：接收平台下发的任务
   - 功能：WebSocket连接、HTTP轮询、任务队列

2. **TaskExecutorModule**
   - 职责：执行具体采集任务
   - 功能：插件调用、并发控制、超时管理

3. **StatusReporterModule**
   - 职责：向平台报告状态
   - 功能：心跳发送、资源监控、健康检查

4. **DataUploaderModule**
   - 职责：上传采集结果
   - 功能：数据压缩、批量发送、失败重试

5. **PluginManagerModule**
   - 职责：管理采集插件
   - 功能：插件加载、能力注册、版本管理

## 四、交互流程设计

### 4.1 采集器注册流程

```sequence
采集器->平台: 注册请求(hostname, IP, 采集能力)
平台->平台: 生成collectorId
平台->采集器: 注册响应(collectorId, 配置参数)
采集器->采集器: 存储ID和配置
采集器->平台: 开始定期心跳
```

### 4.2 任务调度与执行流程

```sequence
平台->平台: 调度触发(Cron表达式)
平台->平台: 生成任务批次(TaskBatch)
平台->平台: 为批次选择合适采集器
平台->采集器: 下发采集任务(WebSocket/HTTP)
采集器->采集器: 任务入队
采集器->采集器: 执行采集任务
采集器->平台: 任务状态更新
采集器->平台: 上传采集结果
平台->平台: 处理结果数据
```

### 4.3 采集器心跳机制

```sequence
采集器->平台: 心跳请求(collectorId, 状态)
平台->平台: 更新采集器状态
平台->采集器: 心跳响应(指令、配置更新)
注意->注意: 定期循环(30-60秒)
```

### 4.4 故障处理流程

```sequence
平台->平台: 检测到采集器心跳超时
平台->平台: 标记采集器为不可用
平台->平台: 查找该采集器未完成任务
平台->平台: 重新分配任务给其他采集器
平台->平台: 记录故障日志
```

## 五、接口设计

### 5.1 平台端API

#### 采集器管理接口
- `POST /api/collectors/register` - 采集器注册
- `POST /api/collectors/{id}/heartbeat` - 采集器心跳
- `GET /api/collectors/{id}/config` - 获取配置
- `GET /api/collectors/{id}/tasks` - 获取待执行任务

#### 任务执行接口
- `POST /api/tasks/result` - 上报任务结果
- `PUT /api/tasks/{id}/status` - 更新任务状态
- `POST /api/metrics/batch` - 批量上传指标数据

### 5.2 采集器端API

#### 控制接口
- `POST /api/control/restart` - 重启采集器
- `POST /api/control/pause` - 暂停采集
- `POST /api/control/resume` - 恢复采集

#### 信息接口
- `GET /api/info/status` - 获取状态信息
- `GET /api/info/metrics` - 获取内部指标
- `GET /api/info/plugins` - 获取插件信息

### 5.3 WebSocket接口

#### 平台到采集器
- `task.assign` - 分配新任务
- `task.cancel` - 取消任务
- `config.update` - 配置更新
- `collector.control` - 控制指令

#### 采集器到平台
- `task.status` - 任务状态更新
- `collector.metrics` - 采集器自身运行指标
- `error.report` - 错误报告

## 六、数据结构设计

### 6.1 采集任务数据结构

```json
{
  "taskId": "t-12345678",
  "batchId": "b-87654321",
  "deviceId": 123,
  "metricId": 456,
  "targetAddress": "192.168.1.100",
  "targetPort": 22,
  "metricType": "CPU_USAGE",
  "collectParams": {
    "interval": "5s",
    "timeout": "30s"
  },
  "authInfo": {
    "username": "admin",
    "authType": "PASSWORD"
  },
  "priority": 1,
  "scheduleTime": "2025-05-28T10:15:30Z",
  "timeout": 60000,
  "retryCount": 3
}
```

### 6.2 采集结果数据结构

```json
{
  "taskId": "t-12345678",
  "deviceId": 123,
  "metricId": 456,
  "collectorId": "c-87654321",
  "status": "SUCCESS",
  "metricValue": "78.5",
  "metricUnit": "%",
  "collectionTime": "2025-05-28T10:15:35Z",
  "executionTime": 852,
  "additionalData": {
    "coreCount": 8,
    "processList": "..."
  }
}
```

## 七、高级架构设计

### 7.1 采集器高可用设计

1. **采集器集群**
   - 多采集器负载均衡
   - 根据设备区域和采集器位置优化分配
   - 采集器分组管理

2. **故障转移机制**
   - 任务自动重分配
   - 相似能力采集器优先接管
   - 轻量级集群协调

### 7.2 任务调度高级特性

1. **智能批次分配**
   - 设备地理位置优化
   - 采集器负载均衡
   - 网络拓扑感知

2. **多级优先级管理**
   - 任务紧急程度分级
   - 资源调度策略
   - 抢占式任务执行

3. **采集效率优化**
   - 相似任务批量执行
   - 任务合并与拆分
   - 并行执行最大化

### 7.3 数据传输优化

1. **数据压缩与批处理**
   - 批量结果提交
   - GZIP/Deflate压缩
   - 数据精简策略

2. **智能网络选择**
   - 可用网络自动检测
   - 弱网环境适应
   - 传输协议自适应

### 7.4 安全架构

1. **通信安全**
   - TLS加密传输
   - 双向认证(mTLS)
   - API令牌机制

2. **数据安全**
   - 敏感数据脱敏
   - 日志安全存储
   - 最小权限原则

3. **部署安全**
   - 隔离网络部署
   - 防火墙规则配置
   - 安全扫描与审计

## 八、扩展性设计

### 8.1 插件系统

1. **采集器插件框架**
   - 标准化插件接口
   - 动态加载机制
   - 插件资源隔离

2. **插件市场**
   - 插件远程获取
   - 版本管理与更新
   - 插件依赖解析

### 8.2 适配框架

1. **协议适配器**
   - SNMP/SSH/WMI适配
   - 自定义协议支持
   - 协议转换器

2. **数据转换器**
   - 格式统一化
   - 数据规范化
   - 单位自动转换

## 九、实施路线

### 9.1 阶段一：基础衔接

1. 实现采集器注册与心跳机制
2. 基础任务下发与结果回传
3. 核心API接口实现

### 9.2 阶段二：功能完善

1. 完善任务调度与批次管理
2. 实现WebSocket实时通信
3. 构建监控与状态管理

### 9.3 阶段三：高级特性

1. 实现智能负载均衡与故障转移
2. 优化数据传输与处理流程
3. 增强安全性与可靠性

## 十、关键技术选型

| 组件 | 技术选型 | 说明 |
|------|----------|------|
| 实时通信 | WebSocket | 实时任务推送与状态反馈 |
| 服务发现 | Eureka/Consul | 采集器自动注册与发现 |
| 任务调度 | Quartz/XXL-Job | 灵活的任务触发与管理 |
| 数据存储 | TimescaleDB | 时序数据高效存储 |
| 消息队列 | Kafka | 高吞吐量的数据流处理 |
| 缓存系统 | Redis | 状态缓存与任务排队 |
| 负载均衡 | 自研算法 | 考虑网络拓扑的智能分配 |

## 十一、建议与最佳实践

1. **接口版本控制**：采用显式的API版本管理
2. **优雅降级**：设计故障时的服务降级策略
3. **资源隔离**：避免单个采集任务影响整体系统
4. **指标标准化**：制定统一的指标命名与单位规范
5. **文档先行**：详细的接口文档与设计说明
6. **全链路监控**：构建端到端的监控体系
7. **灰度发布**：采用渐进式更新策略
